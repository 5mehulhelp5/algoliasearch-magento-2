<?php

namespace Algolia\AlgoliaSearch\Model\Product;

use Algolia\AlgoliaSearch\Api\Product\ReplicaManagerInterface;
use Algolia\AlgoliaSearch\Exceptions\AlgoliaException;
use Algolia\AlgoliaSearch\Exceptions\ExceededRetriesException;
use Algolia\AlgoliaSearch\Helper\ConfigHelper;
use Magento\Framework\Exception\LocalizedException;
use Magento\Framework\Exception\NoSuchEntityException;

/**
 * This class is responsible for managing the business logic related to translating the
 * Magento admin configuration to an Algolia replica configuration.
 * This involves:
 *  - Correctly identifying one or more impacted primary indices based on store scoping in Magento
 *  - Setting the replica configuration on the affected primary indices (whether standard or virtual)
 *  - Setting the associated replicas' ranking configuration
 *
 * To minimize the number of operations performed it also seeks to make as few changes as necessary
 * This is achieved by comparing the local Magento admin sorting configuration to Algolia's associated
 * primary index replica configuration prior to performing any updates which should involve
 * either add or delete operations.
 *
 * Lastly, to ensure compatibility with independent Algolia dashboard configuration which can include things
 * like "sorting strategies" that can be generated by Merchandising Studio this class only concerns itself
 * with replicas that is directly managed by Magento.
 *
 */
class ReplicaManager implements ReplicaManagerInterface
{
    public const REPLICA_TRANSFORM_MODE_STANDARD = 1;
    public const REPLICA_TRANSFORM_MODE_VIRTUAL  = 2;
    public const REPLICA_TRANSFORM_MODE_ACTUAL   = 3;

    public function __construct(
        protected ConfigHelper $configHelper
    ) {}

    /**
     * @throws NoSuchEntityException
     * @throws LocalizedException
     */
    protected function hasReplicaConfigurationChanged(string $indexName, int $storeId): bool {
        /*
         * Method 1 (exhaustive)
         * Get the current replica configuration from Algolia
         * Extract the non Magento replicas (e.g. sorting strategies, dashboard managed, etc.)
         * Calculate the new replica setting for Magento
         * Merge the non Magento replicas with new Magento replica config
         * Perform an array diff (this code can be optimized based on how array_diff works)
         * If there is a change return true else return false
         *
         * Method 2 (efficient)
         * Get the current replica configuration from Algolia
         * Remove non Magento replicas from list and call this $old
         * Determine new Magento replica config and call this $new
         * Sort both arrays ($old and $new)
         * Compare the arrays (array diff etc) and return true if not matching (order should not matter)
         *
         * This gets complicated however if we are dealing with stores -
         * so we must abstract the obtaining of the replica configuration from Algolia
         * In other words if a store is using the default config we compare the sorts to the default index
         * If however there is store scoping - we must isolate the store specific index and compare to that
         */

        $old = $this->getMagentoReplicaConfigurationFromAlgolia($indexName, $storeId);
        $new = $this->transformSortingIndicesToReplicaSetting($this->configHelper->getSortingIndices($indexName, $storeId));
        sort($old);
        sort($new);
        return $old === $new;
    }

    protected function getAlgoliaReplicaConfiguration($indexName)
    {
        $currentSettings = $this->algoliaHelper->getSettings($indexName);
        return array_key_exists('replicas', $currentSettings)
            ? $currentSettings['replicas']
            : [];
    }

    /**
     * Obtain the replica configuration from Algolia but only those indices that are
     * relevant to the Magento integration
     *
     * @param string $indexName
     * @param int $storeId
     * @return string[]
     * @throws LocalizedException
     * @throws NoSuchEntityException
     */
    protected function getMagentoReplicaConfigurationFromAlgolia(string $indexName, int $storeId): array
    {
        $sortingIndices = $this->configHelper->getSortingIndices($indexName, $storeId);
        $algoliaReplicas = $this->getAlgoliaReplicaConfiguration($indexName);
        $magentoReplicas = $this->getPossibleMagentoReplicaSettings($sortingIndices);
        return array_intersect($magentoReplicas, $algoliaReplicas);
    }

    /**
     * @param array $sortingIndices - array of sortingIndices objects
     * @param int $mode Use REPLICA_TRANSFORM_MODE_ constant - defaults to _ACTUAL which will give the configuration defined in the admin panel
     * @return string[]
     */
    protected function transformSortingIndicesToReplicaSetting(
        array $sortingIndices,
        int $mode = self::REPLICA_TRANSFORM_MODE_ACTUAL
    ): array
    {
        return array_map(
            function($sort) {
                $replica = $sort['name'];
                if (
                    $sort['virtualReplica'] && $mode === self::REPLICA_TRANSFORM_MODE_ACTUAL
                    || $mode === self::REPLICA_TRANSFORM_MODE_VIRTUAL
                ) {
                    $replica = "virtual($replica)";
                }
                return $replica;
            },
            $sortingIndices
        );
    }

    protected function getPossibleMagentoReplicaSettings(array $sortingIndices): array {
        return array_merge(
            $this->transformSortingIndicesToReplicaSetting($sortingIndices, self::REPLICA_TRANSFORM_MODE_STANDARD),
            $this->transformSortingIndicesToReplicaSetting($sortingIndices, self::REPLICA_TRANSFORM_MODE_VIRTUAL)
        );
    }

    /**
     * @param string $indexName - could be tmp (legacy impl)
     * @param int $storeId
     * @return void
     *
     * @throws AlgoliaException
     * @throws ExceededRetriesException
     * @throws LocalizedException
     * @throws NoSuchEntityException
     */
    public function handleReplicas(string $indexName, int $storeId): void
    {
        if ($this->configHelper->isInstantEnabled($storeId)
            && $this->hasReplicaConfigurationChanged($indexName, $storeId))
        {
            // We only care about configuring ranking for replicas that were added!
            $addedReplicas = $this->setReplicasOnPrimaryIndex($indexName, $storeId);
        }
    }

    /**
     * @param $indexName
     * @param int $storeId
     * @return string[] Replicas added by this operation
     * @throws LocalizedException
     * @throws NoSuchEntityException
     */
    protected function setReplicasOnPrimaryIndex($indexName, int $storeId): array
    {
        $oldReplicas = $this->getAlgoliaReplicaConfiguration($indexName);
        $newReplicas = $this->transformSortingIndicesToReplicaSetting($this->configHelper->getsortingIndices($indexName, $storeId));
        $replicasToDelete = array_diff($oldReplicas, $newReplicas);
        $replicasToAdd = array_diff($oldReplicas, $newReplicas);
        $this->algoliaHelper->setSettings($indexName, ['replicas' => $newReplicas]);
        $setReplicasTaskId = $this->algoliaHelper->getLastTaskId();
        $this->algoliaHelper->waitLastTask($indexName, $setReplicasTaskId);
        $this->deleteReplicas($replicasToDelete);
        return $replicasToAdd;
    }

    protected function deleteReplicas(array $replicasToDelete): void
    {
        foreach ($replicasToDelete as $deletedReplica) {
            $this->algoliaHelper->deleteIndex($deletedReplica);
        }

    }
}

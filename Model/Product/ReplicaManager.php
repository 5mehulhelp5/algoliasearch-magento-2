<?php

declare(strict_types=1);

namespace Algolia\AlgoliaSearch\Model\Product;

use Algolia\AlgoliaSearch\Api\Product\ReplicaManagerInterface;
use Algolia\AlgoliaSearch\Exception\ReplicaLimitExceededException;
use Algolia\AlgoliaSearch\Exception\TooManyCustomerGroupsAsReplicasException;
use Algolia\AlgoliaSearch\Exceptions\AlgoliaException;
use Algolia\AlgoliaSearch\Helper\AlgoliaHelper;
use Algolia\AlgoliaSearch\Helper\ConfigHelper;
use Algolia\AlgoliaSearch\Helper\Logger;
use Algolia\AlgoliaSearch\Validator\VirtualReplicaValidatorFactory;
use Algolia\AlgoliaSearch\Registry\ReplicaState;
use Magento\Framework\Exception\LocalizedException;
use Magento\Framework\Exception\NoSuchEntityException;

/**
 * This class is responsible for managing the business logic related to translating the
 * Magento admin configuration to an Algolia replica configuration.
 * This involves:
 *  - Correctly identifying one or more impacted primary indices based on store scoping in Magento
 *  - Setting the replica configuration on the affected primary indices (whether standard or virtual)
 *  - Setting the associated replicas' ranking configuration
 *
 * To minimize the number of operations performed it also seeks to make as few changes as necessary
 * This is achieved by comparing the local Magento admin sorting configuration to Algolia's associated
 * primary index replica configuration prior to performing any updates which should involve
 * either add or delete operations.
 *
 * Lastly, to ensure compatibility with independent Algolia dashboard configuration which can include things
 * like "sorting strategies" that can be generated by Merchandising Studio this class only concerns itself
 * with replicas that is directly managed by Magento.
 *
 */
class ReplicaManager implements ReplicaManagerInterface
{
    public const REPLICA_TRANSFORM_MODE_STANDARD = 1;
    public const REPLICA_TRANSFORM_MODE_VIRTUAL = 2;
    public const REPLICA_TRANSFORM_MODE_ACTUAL = 3;

    protected const _DEBUG = true;

    protected array $_algoliaReplicaConfig = [];
    protected array $_magentoReplicaPossibleConfig = [];

    public function __construct(
        protected ConfigHelper                   $configHelper,
        protected AlgoliaHelper                  $algoliaHelper,
        protected ReplicaState                   $replicaState,
        protected VirtualReplicaValidatorFactory $validatorFactory,
        protected Logger                         $logger
    )
    {}

    /**
     * Evaluate the replica state of the index for a given store and determine
     * if Algolia and Magento are no longer in sync
     *
     * @return bool Returns true if Magento and Algolia are out of sync, otherwise false if they are up-to-date
     * @throws NoSuchEntityException
     * @throws LocalizedException
     */
    protected function hasReplicaConfigurationChanged(string $primaryIndexName, int $storeId): bool
    {
        switch ($this->replicaState->getChangeState($storeId)) {
            case ReplicaState::REPLICA_STATE_CHANGED:
                return true;
            case ReplicaState::REPLICA_STATE_UNCHANGED:
                return false;
            case ReplicaState::REPLICA_STATE_UNKNOWN:
            default:
                $old = $this->getMagentoReplicaConfigurationFromAlgolia($primaryIndexName);
                $new = $this->transformSortingIndicesToReplicaSetting($this->configHelper->getSortingIndices($primaryIndexName, $storeId));
                sort($old);
                sort($new);
                return $old !== $new;
        }
    }

    /**
     * @param $primaryIndexName
     * @param bool $refreshCache
     * @return array<string, mixed>
     * @throws LocalizedException
     */
    protected function getReplicaConfigurationFromAlgolia($primaryIndexName, bool $refreshCache = false): array
    {
        if ($refreshCache || !isset($this->_algoliaReplicaConfig[$primaryIndexName])) {
            try {
                $currentSettings = $this->algoliaHelper->getSettings($primaryIndexName);
                $this->_algoliaReplicaConfig[$primaryIndexName] = array_key_exists('replicas', $currentSettings)
                    ? $currentSettings['replicas']
                    : [];
            } catch (\Exception $e) {
                $msg = "Unable to retrieve replica settings for $primaryIndexName: " . $e->getMessage();
                $this->logger->error($msg);
                throw new LocalizedException(__($msg));
            }
        }
        return $this->_algoliaReplicaConfig[$primaryIndexName];
    }

    protected function clearAlgoliaReplicaSettingCache($primaryIndexName = null): void
    {
        if (is_null($primaryIndexName)) {
            $this->_algoliaReplicaConfig = [];
        } else {
            unset($this->_algoliaReplicaConfig[$primaryIndexName]);
        }
    }

    /**
     * Obtain the replica configuration from Algolia but only those indices that are
     * relevant to the Magento integration
     *
     * @param string $primaryIndexName
     * @return string[]
     * @throws LocalizedException
     */
    protected function getMagentoReplicaConfigurationFromAlgolia(string $primaryIndexName): array
    {
        $algoliaReplicas = $this->getReplicaConfigurationFromAlgolia($primaryIndexName);
        $magentoReplicas = $this->getMagentoReplicaSettings($primaryIndexName, $algoliaReplicas);
        return array_values(array_intersect($magentoReplicas, $algoliaReplicas));
    }

    /**
     * Replicas will be considered Magento managed if they are prefixed with the primary index name
     * @param string $baseIndexName
     * @param string[] $algoliaReplicas
     * @return string[]
     */
    protected function getMagentoReplicaSettings(string $baseIndexName, array $algoliaReplicas): array
    {
        return array_filter(
            $algoliaReplicas,
            function ($algoliaReplicaSetting) use ($baseIndexName) {
                return str_starts_with($this->getBareIndexNameFromReplicaSetting($algoliaReplicaSetting), $baseIndexName);
            }
        );
    }

    /**
     * @param string $primaryIndexName
     * @return array
     * @throws LocalizedException
     */
    protected function getNonMagentoReplicaConfigurationFromAlgolia(string $primaryIndexName): array
    {
        $algoliaReplicas = $this->getReplicaConfigurationFromAlgolia($primaryIndexName);
        $magentoReplicas = $this->getMagentoReplicaSettings($primaryIndexName, $algoliaReplicas);
        return array_diff($algoliaReplicas, $magentoReplicas);
    }

    /**
     * @param array $sortingIndices - array of sortingIndices objects
     * @param int $mode Use REPLICA_TRANSFORM_MODE_ constant - defaults to _ACTUAL which will give the configuration defined in the admin panel
     * @return string[]
     */
    protected function transformSortingIndicesToReplicaSetting(
        array $sortingIndices,
        int   $mode = self::REPLICA_TRANSFORM_MODE_ACTUAL
    ): array
    {
        return array_map(
            function ($sort) use ($mode) {
                $replica = $sort['name'];
                if (
                    $mode === self::REPLICA_TRANSFORM_MODE_VIRTUAL
                    || !empty($sort[self::SORT_KEY_VIRTUAL_REPLICA]) && $mode === self::REPLICA_TRANSFORM_MODE_ACTUAL
                ) {
                    $replica = "virtual($replica)";
                }
                return $replica;
            },
            $sortingIndices
        );
    }

    /**
     * In order to avoid interfering with replicas configured directly in the Algolia dashboard,
     * we must know which replica indices are Magento managed and which are not.
     *
     * @param string $primaryIndexName
     * @param int $storeId
     * @param bool $refreshCache
     * @return array
     * @throws LocalizedException
     * @throws NoSuchEntityException
     */
    protected function getMagentoReplicaSettingsFromConfig(string $primaryIndexName, int $storeId, bool $refreshCache = false): array
    {
        if ($refreshCache || !isset($this->_magentoReplicaPossibleConfig[$storeId])) {
            $sortConfig = $this->replicaState->getChangeState($storeId) === ReplicaState::REPLICA_STATE_CHANGED
                ? array_merge($this->replicaState->getOriginalSortConfiguration($storeId), $this->replicaState->getUpdatedSortConfiguration($storeId))
                : null;
            $sortingIndices = $this->configHelper->getSortingIndices($primaryIndexName, $storeId, null, $sortConfig);
            $this->_magentoReplicaPossibleConfig[$storeId] = array_merge(
                $this->transformSortingIndicesToReplicaSetting($sortingIndices, self::REPLICA_TRANSFORM_MODE_STANDARD),
                $this->transformSortingIndicesToReplicaSetting($sortingIndices, self::REPLICA_TRANSFORM_MODE_VIRTUAL)
            );
        }
        return $this->_magentoReplicaPossibleConfig[$storeId];
    }

    /**
     * @inheritDoc
     */
    public function handleReplicas(string $primaryIndexName, int $storeId, array $primaryIndexSettings): void
    {
        if ($this->isReplicaSyncEnabled($storeId)
            && $this->hasReplicaConfigurationChanged($primaryIndexName, $storeId)
            && $this->isReplicaConfigurationValid($primaryIndexName, $storeId)) {
            $addedReplicas = $this->setReplicasOnPrimaryIndex($primaryIndexName, $storeId);
            $this->configureRanking($primaryIndexName, $storeId, $addedReplicas, $primaryIndexSettings);
        }
    }

    /**
     * @param string $indexName
     * @param int $storeId
     * @return string[] Replicas added or modified by this operation
     * @throws LocalizedException
     * @throws NoSuchEntityException
     * @throws AlgoliaException
     */
    protected function setReplicasOnPrimaryIndex(string $indexName, int $storeId): array
    {
        $sortingIndices = $this->configHelper->getSortingIndices($indexName, $storeId);
        $newMagentoReplicasSetting = $this->transformSortingIndicesToReplicaSetting($sortingIndices);
        $oldMagentoReplicasSetting = $this->getMagentoReplicaConfigurationFromAlgolia($indexName);
        $nonMagentoReplicasSetting = $this->getNonMagentoReplicaConfigurationFromAlgolia($indexName);
        $oldMagentoReplicaIndices = $this->getBareIndexNamesFromReplicaSetting($oldMagentoReplicasSetting);
        $newMagentoReplicaIndices = $this->getBareIndexNamesFromReplicaSetting($newMagentoReplicasSetting);

        $replicasToDelete = array_diff($oldMagentoReplicaIndices, $newMagentoReplicaIndices);
        $replicasToAdd = array_diff($newMagentoReplicaIndices, $oldMagentoReplicaIndices);
        $replicasToRank = $this->getBareIndexNamesFromReplicaSetting(array_diff($newMagentoReplicasSetting, $oldMagentoReplicasSetting));
        $replicasToUpdate = array_diff($replicasToRank, $replicasToAdd);

        $this->algoliaHelper->setSettings(
            $indexName,
            ['replicas' => array_merge($newMagentoReplicasSetting, $nonMagentoReplicasSetting)]
        );
        $setReplicasTaskId = $this->algoliaHelper->getLastTaskId();
        $this->algoliaHelper->waitLastTask($indexName, $setReplicasTaskId);
        $this->clearAlgoliaReplicaSettingCache($indexName);
        $this->deleteReplicas($replicasToDelete);

        if (self::_DEBUG) {
            $this->logger->log(
                "Replicas configured on $indexName for store $storeId: "
                . count($replicasToAdd) . ' added, '
                . count($replicasToUpdate) . ' updated, '
                . count($replicasToDelete) . ' deleted'
            );
        }

        // include both added and updated replica indices
        return $replicasToRank;
    }

    /**
     * @param string $primaryIndexName
     * @param int $storeId
     * @return bool
     * @throws LocalizedException
     * @throws NoSuchEntityException
     * @throws ReplicaLimitExceededException
     */
    protected function isReplicaConfigurationValid(string $primaryIndexName, int $storeId): bool
    {
        $sortingIndices = $this->configHelper->getSortingIndices($primaryIndexName, $storeId);
        $validator = $this->validatorFactory->create();
        if (!$validator->isReplicaConfigurationValid($sortingIndices)) {
            // TODO: Implement revert settings via ReplicaState
            if ($validator->isTooManyCustomerGroups()) {
                throw (new TooManyCustomerGroupsAsReplicasException("You have too many customer groups to enable virtual replicas on the pricing sort."))
                    ->withReplicaCount($validator->getReplicaCount())
                    ->withPriceSortReplicaCount($validator->getPriceSortReplicaCount());
            }
            else {
                throw (new ReplicaLimitExceededException("Replica limit exceeded."))
                    ->withReplicaCount($validator->getReplicaCount());
            }
        }
        return true;
    }

    /**
     * @param string[] $replicas
     * @return string[]
     */
    protected function getBareIndexNamesFromReplicaSetting(array $replicas): array
    {
        return array_map(
            function ($str) {
                return $this->getBareIndexNameFromReplicaSetting($str);
            },
            $replicas
        );
    }

    protected function getBareIndexNameFromReplicaSetting(string $replicaSetting): string
    {
        return preg_replace('/.*\((.*)\).*/', '$1', $replicaSetting);
    }

    /**
     * @param array $replicasToDelete
     * @return void
     * @throws AlgoliaException
     */
    protected function deleteReplicas(array $replicasToDelete): void
    {
        foreach ($replicasToDelete as $deletedReplica) {
            $this->algoliaHelper->deleteIndex($deletedReplica);
        }
    }

    /**
     * Apply ranking settings to the added replica indices
     * @param string $primaryIndexName
     * @param int $storeId
     * @param string[] $replicas
     * @param array<string, mixed> $primaryIndexSettings
     * @return void
     * @throws AlgoliaException
     * @throws LocalizedException
     * @throws NoSuchEntityException
     */
    protected function configureRanking(string $primaryIndexName, int $storeId, array $replicas, array $primaryIndexSettings): void
    {
        $sortingIndices = $this->configHelper->getSortingIndices($primaryIndexName, $storeId);
        $replicaDetails = array_filter(
            $sortingIndices,
            function($replica) use ($replicas) {
                return in_array($replica['name'], $replicas);
            }
        );
        foreach ($replicaDetails as $replica) {
            $replicaName = $replica['name'];
            // Virtual replicas - relevant sort
            if (!empty($replica[self::SORT_KEY_VIRTUAL_REPLICA])) {
                $customRanking = array_key_exists('customRanking', $primaryIndexSettings)
                    ? $primaryIndexSettings['customRanking']
                    : [];
                array_unshift($customRanking, $replica['ranking'][0]);
                $this->algoliaHelper->setSettings(
                    $replicaName,
                    [ 'customRanking' => $customRanking ]
                );
            // Standard replicas - exhaustive sort
            } else {
                $primaryIndexSettings['ranking'] = $replica['ranking'];
                $this->algoliaHelper->setSettings(
                    $replicaName,
                    $primaryIndexSettings
                );
            }
        }
    }

    /**
     * @inheritDoc
     */
    public function isReplicaSyncEnabled(int $storeId): bool
    {
        return $this->configHelper->isInstantEnabled($storeId);
    }
}

<?php

declare(strict_types=1);

namespace Algolia\AlgoliaSearch\Model\Product;

use Algolia\AlgoliaSearch\Api\Product\ReplicaManagerInterface;
use Algolia\AlgoliaSearch\Exceptions\AlgoliaException;
use Algolia\AlgoliaSearch\Exceptions\ExceededRetriesException;
use Algolia\AlgoliaSearch\Helper\AlgoliaHelper;
use Algolia\AlgoliaSearch\Helper\ConfigHelper;
use Algolia\AlgoliaSearch\Helper\Logger;
use Algolia\AlgoliaSearch\Registry\ReplicaState;
use Magento\Framework\Exception\LocalizedException;
use Magento\Framework\Exception\NoSuchEntityException;

/**
 * This class is responsible for managing the business logic related to translating the
 * Magento admin configuration to an Algolia replica configuration.
 * This involves:
 *  - Correctly identifying one or more impacted primary indices based on store scoping in Magento
 *  - Setting the replica configuration on the affected primary indices (whether standard or virtual)
 *  - Setting the associated replicas' ranking configuration
 *
 * To minimize the number of operations performed it also seeks to make as few changes as necessary
 * This is achieved by comparing the local Magento admin sorting configuration to Algolia's associated
 * primary index replica configuration prior to performing any updates which should involve
 * either add or delete operations.
 *
 * Lastly, to ensure compatibility with independent Algolia dashboard configuration which can include things
 * like "sorting strategies" that can be generated by Merchandising Studio this class only concerns itself
 * with replicas that is directly managed by Magento.
 *
 */
class ReplicaManager implements ReplicaManagerInterface
{
    public const REPLICA_TRANSFORM_MODE_STANDARD = 1;
    public const REPLICA_TRANSFORM_MODE_VIRTUAL = 2;
    public const REPLICA_TRANSFORM_MODE_ACTUAL = 3;

    protected const _DEBUG = true;

    protected array $_algoliaReplicaConfig = [];
    protected array $_magentoReplicaPossibleConfig = [];

    public function __construct(
        protected ConfigHelper  $configHelper,
        protected AlgoliaHelper $algoliaHelper,
        protected ReplicaState  $replicaState,
        protected Logger        $logger
    )
    {
    }

    /**
     * Evaluate the replica state of the index for a given store and determine
     * if Algolia and Magento are no longer in sync
     *
     * @return bool Returns true if Magento and Algolia are out of sync, otherwise false if they are up-to-date
     * @throws NoSuchEntityException
     * @throws LocalizedException
     */
    protected function hasReplicaConfigurationChanged(string $primaryIndexName, int $storeId): bool
    {
        $old = $this->getMagentoReplicaConfigurationFromAlgolia($primaryIndexName, $storeId);
        $new = $this->transformSortingIndicesToReplicaSetting($this->configHelper->getSortingIndices($primaryIndexName, $storeId));
        sort($old);
        sort($new);
        return $old !== $new;
    }

    protected function getReplicaConfigurationFromAlgolia($primaryIndexName, bool $refreshCache = false)
    {
        if ($refreshCache || !isset($this->_algoliaReplicaConfig[$primaryIndexName])) {
            $currentSettings = $this->algoliaHelper->getSettings($primaryIndexName);
            $this->_algoliaReplicaConfig[$primaryIndexName] = array_key_exists('replicas', $currentSettings)
                ? $currentSettings['replicas']
                : [];
        }
        return $this->_algoliaReplicaConfig[$primaryIndexName];
    }

    protected function clearAlgoliaReplicaSettingCache($primaryIndexName = null): void
    {
        if (is_null($primaryIndexName)) {
            $this->_algoliaReplicaConfig = [];
        } else {
            unset($this->_algoliaReplicaConfig[$primaryIndexName]);
        }
    }

    /**
     * Obtain the replica configuration from Algolia but only those indices that are
     * relevant to the Magento integration
     *
     * @param string $primaryIndexName
     * @param int $storeId
     * @return string[]
     * @throws LocalizedException
     * @throws NoSuchEntityException
     */
    protected function getMagentoReplicaConfigurationFromAlgolia(string $primaryIndexName, int $storeId): array
    {
        $algoliaReplicas = $this->getReplicaConfigurationFromAlgolia($primaryIndexName);
        $magentoReplicas = $this->getPossibleMagentoReplicaSettings($primaryIndexName, $algoliaReplicas);
        return array_values(array_intersect($magentoReplicas, $algoliaReplicas));
    }

    /**
     * Replicas will be considered Magento managed if they are prefixed with the primary index name
     * @param string $baseIndexName
     * @param string[] $algoliaReplicas
     * @return string[]
     */
    protected function getPossibleMagentoReplicaSettings(string $baseIndexName, array $algoliaReplicas): array
    {
        return array_filter(
            $algoliaReplicas,
            function ($algoliaReplicaSetting) use ($baseIndexName) {
                return str_starts_with($this->getBareIndexNameFromReplicaSetting($algoliaReplicaSetting), $baseIndexName);
            }
        );
    }

    /**
     * @throws NoSuchEntityException
     * @throws LocalizedException
     */
    protected function getNonMagentoReplicaConfigurationFromAlgolia(string $primaryIndexName, int $storeId): array
    {
        $algoliaReplicas = $this->getReplicaConfigurationFromAlgolia($primaryIndexName);
        $magentoReplicas = $this->getPossibleMagentoReplicaSettings($primaryIndexName, $algoliaReplicas);
        return array_diff($algoliaReplicas, $magentoReplicas);
    }

    /**
     * @param array $sortingIndices - array of sortingIndices objects
     * @param int $mode Use REPLICA_TRANSFORM_MODE_ constant - defaults to _ACTUAL which will give the configuration defined in the admin panel
     * @return string[]
     */
    protected function transformSortingIndicesToReplicaSetting(
        array $sortingIndices,
        int   $mode = self::REPLICA_TRANSFORM_MODE_ACTUAL
    ): array
    {
        return array_map(
            function ($sort) use ($mode) {
                $replica = $sort['name'];
                if (
                    $mode === self::REPLICA_TRANSFORM_MODE_VIRTUAL
                    || array_key_exists('virtualReplica', $sort)
                    && $sort['virtualReplica']
                    && $mode === self::REPLICA_TRANSFORM_MODE_ACTUAL
                ) {
                    $replica = "virtual($replica)";
                }
                return $replica;
            },
            $sortingIndices
        );
    }

    /**
     * In order to avoid interfering with replicas configured directly in the Algolia dashboard,
     * we must know which replica indices are Magento managed and which are not.
     *
     * @param string $primaryIndexName
     * @param int $storeId
     * @param bool $refreshCache
     * @return array
     * @throws LocalizedException
     * @throws NoSuchEntityException
     */
    protected function getPossibleMagentoReplicaSettingsFromConfig(string $primaryIndexName, int $storeId, bool $refreshCache = false): array
    {
        if ($refreshCache || !isset($this->_magentoReplicaPossibleConfig[$storeId])) {
            //TODO: Determine whether it is necessary to merge the new configuration on an update when checking against Algolia
            $sortConfig = $this->replicaState->isStateChanged()
                ? array_merge($this->replicaState->getOriginalSortConfiguration(), $this->replicaState->getUpdatedSortConfiguration())
                : null;
            $sortingIndices = $this->configHelper->getSortingIndices($primaryIndexName, $storeId, null, $sortConfig);
            $this->_magentoReplicaPossibleConfig[$storeId] = array_merge(
                $this->transformSortingIndicesToReplicaSetting($sortingIndices, self::REPLICA_TRANSFORM_MODE_STANDARD),
                $this->transformSortingIndicesToReplicaSetting($sortingIndices, self::REPLICA_TRANSFORM_MODE_VIRTUAL)
            );
        }
        return $this->_magentoReplicaPossibleConfig[$storeId];
    }

    /**
     * @inheritDoc
     */
    public function handleReplicas(string $primaryIndexName, int $storeId, array $primaryIndexSettings): void
    {
        // TODO: Determine if InstantSearch is a hard requirement (i.e. headless implementations may still need replicas)
        if ($this->configHelper->isInstantEnabled($storeId)
            && $this->hasReplicaConfigurationChanged($primaryIndexName, $storeId)) {
            // TODO: Handle ranking adjustments when toggling virtual vs standard replicas
            $addedReplicas = $this->setReplicasOnPrimaryIndex($primaryIndexName, $storeId);
            $this->configureRanking($primaryIndexName, $storeId, $addedReplicas, $primaryIndexSettings);
        }
    }

    /**
     * @param $primaryIndexName
     * @param int $storeId
     * @return string[] Replicas added or modified by this operation
     * @throws LocalizedException
     * @throws NoSuchEntityException
     * @throws AlgoliaException
     */
    protected function setReplicasOnPrimaryIndex($indexName, int $storeId): array
    {
        $sortingIndices = $this->configHelper->getSortingIndices($indexName, $storeId);
        $newMagentoReplicasSetting = $this->transformSortingIndicesToReplicaSetting($sortingIndices);
        $oldMagentoReplicasSetting = $this->getMagentoReplicaConfigurationFromAlgolia($indexName, $storeId);
        $nonMagentoReplicasSetting = $this->getNonMagentoReplicaConfigurationFromAlgolia($indexName, $storeId);
        $oldMagentoReplicaIndices = $this->getBareIndexNamesFromReplicaSetting($oldMagentoReplicasSetting);
        $newMagentoReplicaIndices = $this->getBareIndexNamesFromReplicaSetting($newMagentoReplicasSetting);

        $replicasToDelete = array_diff($oldMagentoReplicaIndices, $newMagentoReplicaIndices);
        $replicasToAdd = array_diff($newMagentoReplicaIndices, $oldMagentoReplicaIndices);
        $replicasToRank = $this->getBareIndexNamesFromReplicaSetting(array_diff($newMagentoReplicasSetting, $oldMagentoReplicasSetting));
        $replicasToUpdate = array_diff($replicasToRank, $replicasToAdd);

        $this->algoliaHelper->setSettings(
            $indexName,
            ['replicas' => array_merge($newMagentoReplicasSetting, $nonMagentoReplicasSetting)]
        );
        $setReplicasTaskId = $this->algoliaHelper->getLastTaskId();
        $this->algoliaHelper->waitLastTask($indexName, $setReplicasTaskId);
        $this->clearAlgoliaReplicaSettingCache($indexName);
        $this->deleteReplicas($replicasToDelete);

        if (self::_DEBUG) {
            $this->logger->log(
                "Replicas configured on $indexName for store $storeId: "
                . count($replicasToAdd) . ' added, '
                . count($replicasToUpdate) . ' updated, '
                . count($replicasToDelete) . ' deleted'
            );
        }

        // include both added and updated replica indices
        return $replicasToRank;
    }

    /**
     * @param string[] $replicas
     * @return string[]
     */
    protected function getBareIndexNamesFromReplicaSetting(array $replicas): array
    {
        return array_map(
            function ($str) {
                return $this->getBareIndexNameFromReplicaSetting($str);
            },
            $replicas
        );
    }

    protected function getBareIndexNameFromReplicaSetting(string $replicaSetting): string
    {
        return preg_replace('/.*\((.*)\).*/', '$1', $replicaSetting);
    }

    protected function deleteReplicas(array $replicasToDelete): void
    {
        foreach ($replicasToDelete as $deletedReplica) {
            $this->algoliaHelper->deleteIndex($deletedReplica);
        }
    }

    /**
     * Apply ranking settings to the added replica indices
     * @param string $primaryIndexName
     * @param int $storeId
     * @param string[] $replicas
     * @param array<string, mixed> $primaryIndexSettings
     * @return void
     * @throws AlgoliaException
     * @throws LocalizedException
     * @throws NoSuchEntityException
     */
    protected function configureRanking(string $primaryIndexName, int $storeId, array $replicas, array $primaryIndexSettings): void
    {
        $sortingIndices = $this->configHelper->getSortingIndices($primaryIndexName, $storeId);
        $replicaDetails = array_filter(
            $sortingIndices,
            function($replica) use ($replicas) {
                return in_array($replica['name'], $replicas);
            }
        );
        foreach ($replicaDetails as $replica) {
            $replicaName = $replica['name'];
            // Virtual replicas - relevant sort
            if ($replica['virtualReplica']) {
                $customRanking = array_key_exists('customRanking', $primaryIndexSettings)
                    ? $primaryIndexSettings['customRanking']
                    : [];
                array_unshift($customRanking, $replica['ranking'][0]);
                $this->algoliaHelper->setSettings(
                    $replicaName,
                    [ 'customRanking' => $customRanking ]
                );
            // Standard replicas - exhaustive sort
            } else {
                $primaryIndexSettings['ranking'] = $replica['ranking'];
                $this->algoliaHelper->setSettings(
                    $replicaName,
                    $primaryIndexSettings
                );
            }
        }
    }
}

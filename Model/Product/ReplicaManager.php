<?php

declare(strict_types=1);

namespace Algolia\AlgoliaSearch\Model\Product;

use Algolia\AlgoliaSearch\Api\Product\ReplicaManagerInterface;
use Algolia\AlgoliaSearch\Exceptions\AlgoliaException;
use Algolia\AlgoliaSearch\Exceptions\ExceededRetriesException;
use Algolia\AlgoliaSearch\Helper\AlgoliaHelper;
use Algolia\AlgoliaSearch\Helper\ConfigHelper;
use Algolia\AlgoliaSearch\Registry\ReplicaState;
use Magento\Framework\Exception\LocalizedException;
use Magento\Framework\Exception\NoSuchEntityException;

/**
 * This class is responsible for managing the business logic related to translating the
 * Magento admin configuration to an Algolia replica configuration.
 * This involves:
 *  - Correctly identifying one or more impacted primary indices based on store scoping in Magento
 *  - Setting the replica configuration on the affected primary indices (whether standard or virtual)
 *  - Setting the associated replicas' ranking configuration
 *
 * To minimize the number of operations performed it also seeks to make as few changes as necessary
 * This is achieved by comparing the local Magento admin sorting configuration to Algolia's associated
 * primary index replica configuration prior to performing any updates which should involve
 * either add or delete operations.
 *
 * Lastly, to ensure compatibility with independent Algolia dashboard configuration which can include things
 * like "sorting strategies" that can be generated by Merchandising Studio this class only concerns itself
 * with replicas that is directly managed by Magento.
 *
 */
class ReplicaManager implements ReplicaManagerInterface
{
    public const REPLICA_TRANSFORM_MODE_STANDARD = 1;
    public const REPLICA_TRANSFORM_MODE_VIRTUAL  = 2;
    public const REPLICA_TRANSFORM_MODE_ACTUAL   = 3;

    protected array $_algoliaReplicaConfig = [];
    protected array $_magentoReplicaPossibleConfig = [];

    public function __construct(
        protected ConfigHelper $configHelper,
        protected AlgoliaHelper $algoliaHelper,
        protected ReplicaState $replicaState
    ) {}

    /**
     * Evaluate the replica state of the index for a given store and determine
     * if Algolia and Magento are no longer in sync
     *
     * @return bool Returns true if Magento and Algolia are out of sync, otherwise false if they are up-to-date
     * @throws NoSuchEntityException
     * @throws LocalizedException
     */
    protected function hasReplicaConfigurationChanged(string $indexName, int $storeId): bool {
        /*
         * Method 1 (exhaustive)
         * Get the current replica configuration from Algolia
         * Extract the non Magento replicas (e.g. sorting strategies, dashboard managed, etc.)
         * Calculate the new replica setting for Magento
         * Merge the non Magento replicas with new Magento replica config
         * Perform an array diff (this code can be optimized based on how array_diff works)
         * If there is a change return true else return false
         *
         * Method 2 (efficient)
         * Get the current replica configuration from Algolia
         * Remove non Magento replicas from list and call this $old
         * Determine new Magento replica config and call this $new
         * Sort both arrays ($old and $new)
         * Compare the arrays (array diff etc) and return true if not matching (order should not matter)
         *
         * This gets complicated however if we are dealing with stores -
         * so we must abstract the obtaining of the replica configuration from Algolia
         * In other words if a store is using the default config we compare the sorts to the default index
         * If however there is store scoping - we must isolate the store specific index and compare to that
         */

        $old = $this->getMagentoReplicaConfigurationFromAlgolia($indexName, $storeId);
        $new = $this->transformSortingIndicesToReplicaSetting($this->configHelper->getSortingIndices($indexName, $storeId));
        sort($old);
        sort($new);
        return $old !== $new;
    }

    protected function getReplicaConfigurationFromAlgolia($indexName, bool $refreshCache = false)
    {
        if ($refreshCache || !isset($this->_algoliaReplicaConfig[$indexName])) {
            $currentSettings = $this->algoliaHelper->getSettings($indexName);
            $this->_algoliaReplicaConfig[$indexName] = array_key_exists('replicas', $currentSettings)
                ? $currentSettings['replicas']
                : [];
        }
        return $this->_algoliaReplicaConfig[$indexName];
    }

    protected function clearAlgoliaReplicaSettingCache($indexName = null): void
    {
        if (is_null($indexName)) {
            $this->_algoliaReplicaConfig = [];
        }
        else
        {
            unset($this->_algoliaReplicaConfig[$indexName]);
        }
    }

    /**
     * Obtain the replica configuration from Algolia but only those indices that are
     * relevant to the Magento integration
     *
     * @param string $indexName
     * @param int $storeId
     * @return string[]
     * @throws LocalizedException
     * @throws NoSuchEntityException
     */
    protected function getMagentoReplicaConfigurationFromAlgolia(string $indexName, int $storeId): array
    {
        $algoliaReplicas = $this->getReplicaConfigurationFromAlgolia($indexName);
        $magentoReplicas = $this->getPossibleMagentoReplicaSettings($indexName, $storeId);
        return array_values(array_intersect($magentoReplicas, $algoliaReplicas));
    }

    /**
     * @throws NoSuchEntityException
     * @throws LocalizedException
     */
    protected function getNonMagentoReplicaConfigurationFromAlgolia(string $indexName, int $storeId): array
    {
        $algoliaReplicas = $this->getReplicaConfigurationFromAlgolia($indexName);
        $magentoReplicas = $this->getPossibleMagentoReplicaSettings($indexName, $storeId);
        return array_diff($algoliaReplicas, $magentoReplicas);
    }

    /**
     * @param array $sortingIndices - array of sortingIndices objects
     * @param int $mode Use REPLICA_TRANSFORM_MODE_ constant - defaults to _ACTUAL which will give the configuration defined in the admin panel
     * @return string[]
     */
    protected function transformSortingIndicesToReplicaSetting(
        array $sortingIndices,
        int $mode = self::REPLICA_TRANSFORM_MODE_ACTUAL
    ): array
    {
        return array_map(
            function($sort) use ($mode) {
                $replica = $sort['name'];
                if (
                    $mode === self::REPLICA_TRANSFORM_MODE_VIRTUAL
                    || array_key_exists('virtualReplica', $sort)
                        && $sort['virtualReplica']
                        && $mode === self::REPLICA_TRANSFORM_MODE_ACTUAL
                ) {
                    $replica = "virtual($replica)";
                }
                return $replica;
            },
            $sortingIndices
        );
    }

    /**
     * In order to avoid interfering with replicas configured directly in the Algolia dashboard,
     * we must know which replica indices are Magento managed and which are not.
     *
     * @param string $indexName
     * @param int $storeId
     * @param bool $refreshCache
     * @return array
     * @throws LocalizedException
     * @throws NoSuchEntityException
     */
    protected function getPossibleMagentoReplicaSettings(string $indexName, int $storeId, bool $refreshCache = false): array
    {
        if ($refreshCache || !isset($this->_magentoReplicaPossibleConfig[$storeId])) {
            //TODO: Determine whether it is necessary to merge the new configuration on an update when checking against Algolia
            $sortConfig = $this->replicaState->isStateChanged()
                ? array_merge($this->replicaState->getOriginalSortConfiguration(), $this->replicaState->getUpdatedSortConfiguration())
                : null;
            $sortingIndices = $this->configHelper->getSortingIndices($indexName, $storeId, null, $sortConfig);
            $this->_magentoReplicaPossibleConfig[$storeId] = array_merge(
                $this->transformSortingIndicesToReplicaSetting($sortingIndices, self::REPLICA_TRANSFORM_MODE_STANDARD),
                $this->transformSortingIndicesToReplicaSetting($sortingIndices, self::REPLICA_TRANSFORM_MODE_VIRTUAL)
            );
        }
        return $this->_magentoReplicaPossibleConfig[$storeId];
    }

    /**
     * @inheritDoc
     */
    public function handleReplicas(string $indexName, int $storeId, array $primaryIndexSettings): void
    {
        // TODO: Determine if InstantSearch is a hard requirement (i.e. headless implementations may still need replicas)
        if ($this->configHelper->isInstantEnabled($storeId)
            && $this->hasReplicaConfigurationChanged($indexName, $storeId))
        {
            // TODO: Handle ranking adjustments when toggling virtual vs standard replicas
            $addedReplicas = $this->setReplicasOnPrimaryIndex($indexName, $storeId);
            $this->configureRanking($indexName, $storeId, $addedReplicas, $primaryIndexSettings);
        }
    }

    /**
     * @param $indexName
     * @param int $storeId
     * @return string[] Replicas added by this operation
     * @throws LocalizedException
     * @throws NoSuchEntityException
     * @throws AlgoliaException
     */
    protected function setReplicasOnPrimaryIndex($indexName, int $storeId): array
    {
        $sortingIndices = $this->configHelper->getSortingIndices($indexName, $storeId);
        $newMagentoReplicas = $this->transformSortingIndicesToReplicaSetting($sortingIndices);
        $oldMagentoReplicas = $this->getMagentoReplicaConfigurationFromAlgolia($indexName, $storeId);
        $nonMagentoReplicas = $this->getNonMagentoReplicaConfigurationFromAlgolia($indexName, $storeId);
        $oldMagentoReplicaIndices = $this->getBareIndexNamesFromReplicaSetting($oldMagentoReplicas);
        $newMagentoReplicaIndices = $this->getBareIndexNamesFromReplicaSetting($newMagentoReplicas);
        $replicasToDelete = array_diff($oldMagentoReplicaIndices, $newMagentoReplicaIndices);
        $replicasToAdd = array_diff($newMagentoReplicaIndices, $oldMagentoReplicaIndices);
        $this->algoliaHelper->setSettings($indexName, ['replicas' => array_merge($newMagentoReplicas, $nonMagentoReplicas)]);
        $setReplicasTaskId = $this->algoliaHelper->getLastTaskId();
        $this->algoliaHelper->waitLastTask($indexName, $setReplicasTaskId);
        $this->clearAlgoliaReplicaSettingCache($indexName);
        $this->deleteReplicas($replicasToDelete);
        return $replicasToAdd;
    }

    function getBareIndexNamesFromReplicaSetting(array $replicas): array
    {
        return array_map(
            function($str) {
                return preg_replace('/.*\((.*)\).*/', '$1', $str);
            },
            $replicas
        );
    }

    protected function deleteReplicas(array $replicasToDelete): void
    {
        foreach ($replicasToDelete as $deletedReplica) {
            $this->algoliaHelper->deleteIndex($deletedReplica);
        }
    }

    /**
     * Apply ranking settings to the added replica indices
     * @param string $indexName
     * @param int $storeId
     * @param string[] $replicas
     * @param array<string, mixed> $primaryIndexSettings
     * @return void
     * @throws AlgoliaException
     * @throws LocalizedException
     * @throws NoSuchEntityException
     */
    protected function configureRanking(string $indexName, int $storeId, array $replicas, array $primaryIndexSettings): void
    {
        $sortingIndices = $this->configHelper->getSortingIndices($indexName, $storeId);
        $replicaDetails = array_filter(
            $sortingIndices,
            function($replica) use ($replicas) {
                return in_array($replica['name'], $replicas);
            }
        );
        foreach ($replicaDetails as $replica) {
            $replicaName = $replica['name'];
            // Virtual replicas - relevant sort
            if ($replica['virtualReplica']) {
                $customRanking = array_key_exists('customRanking', $primaryIndexSettings)
                    ? $primaryIndexSettings['customRanking']
                    : [];
                array_unshift($customRanking, $replica['ranking'][0]);
                $this->algoliaHelper->setSettings(
                    $replicaName,
                    [ 'customRanking' => $customRanking ]
                );
            // Standard replicas - exhaustive sort
            } else {
                $primaryIndexSettings['ranking'] = $replica['ranking'];
                $this->algoliaHelper->setSettings(
                    $replicaName,
                    $primaryIndexSettings
                );
            }
        }
    }
}
